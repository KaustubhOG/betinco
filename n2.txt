// {
//   "address": "H5xTV9x61nDR2kLTKXekM4YntaNUpCNEDxZYVmZpre77",
//   "metadata": {
//     "name": "betinco",
//     "version": "0.1.0",
//     "spec": "0.1.0"
//   },
//   "instructions": [
//     {
//       "name": "initialize_market",
//       "discriminator": [35, 35, 189, 193, 155, 48, 170, 203],
//       "accounts": [
//         { "name": "market", "writable": true },
//         { "name": "authority", "writable": true, "signer": true },
//         { "name": "collateral_mint" },
//         { "name": "collateral_vault", "writable": true },
//         { "name": "token_program" },
//         { "name": "system_program" },
//         { "name": "rent" }
//       ],
//       "args": [
//         { "name": "market_id", "type": "u32" },
//         { "name": "question", "type": "string" },
//         { "name": "settlement_deadline", "type": "i64" }
//       ]
//     },
//     {
//       "name": "place_bet_private",
//       "discriminator": [124, 168, 192, 70, 246, 35, 211, 100],
//       "accounts": [
//         { "name": "market", "writable": true },
//         { "name": "user", "writable": true, "signer": true },
//         { "name": "user_collateral", "writable": true },
//         { "name": "collateral_vault", "writable": true },
//         { "name": "token_program" },
//         { "name": "inco_lightning_program" },
//         { "name": "bet_account", "writable": true },
//         { "name": "system_program" }
//       ],
//       "args": [
//         { "name": "market_id", "type": "u32" },
//         { "name": "amount", "type": "u64" },
//         { "name": "is_private_mode", "type": "bool" },
//         { "name": "encrypted_bet_data", "type": "bytes" }
//       ]
//     },
//     {
//       "name": "set_winning_side",
//       "discriminator": [228, 154, 61, 145, 237, 24, 26, 15],
//       "accounts": [
//         { "name": "authority", "writable": true, "signer": true },
//         { "name": "market", "writable": true }
//       ],
//       "args": [
//         { "name": "market_id", "type": "u32" },
//         { "name": "winner", "type": { "defined": { "name": "WinningOutcome" } } }
//       ]
//     },
//     {
//       "name": "claim_private",
//       "discriminator": [142, 102, 171, 214, 242, 186, 131, 246],
//       "accounts": [
//         { "name": "user", "writable": true, "signer": true },
//         { "name": "market", "writable": true },
//         { "name": "user_collateral", "writable": true },
//         { "name": "collateral_vault", "writable": true },
//         { "name": "bet_account", "writable": true },
//         { "name": "token_program" },
//         { "name": "inco_lightning_program" },
//         { "name": "instructions_sysvar" }
//       ],
//       "args": [
//         { "name": "market_id", "type": "u32" },
//         { "name": "inco_proof", "type": "bytes" }
//       ]
//     }
//   ],
//   "types": [
//     {
//       "name": "WinningOutcome",
//       "type": {
//         "kind": "enum",
//         "variants": [
//           { "name": "OutcomeA" },
//           { "name": "OutcomeB" },
//           { "name": "Neither" }
//         ]
//       }
//     }
//   ]
// }


// import { PublicKey } from "@solana/web3.js";

// export async function encryptBetData(
//   amount: number,
//   side: number,
//   userPublicKey: PublicKey
// ): Promise<{
//   encryptedAmount: Buffer;
//   encryptedSide: Buffer;
// }> {
//   try {
//     console.log("üîí Inco Encryption START - Side:", side);

//     // Dynamic import to handle SSR
//     const { encryptValue } = await import("@inco/solana-sdk/encryption");
//     const { hexToBuffer } = await import("@inco/solana-sdk/utils");

//     // Encrypt only the side (0 = YES, 1 = NO)
//     const sideBigInt = BigInt(side);
//     const encryptedSideHex = await encryptValue(sideBigInt);

//     console.log("‚úÖ Side encrypted");

//     const encryptedSide = hexToBuffer(encryptedSideHex);

//     // Return dummy amount buffer (not used in public mode)
//     const dummyAmount = Buffer.alloc(0);

//     console.log("üì¶ Encrypted Side buffer size:", encryptedSide.length);
//     console.log("üîí Inco Encryption COMPLETE");

//     return {
//       encryptedAmount: dummyAmount,
//       encryptedSide: encryptedSide,
//     };
//   } catch (error) {
//     console.error("‚ùå Encryption failed:", error);
    
//     // Fallback: create encrypted data for testing (16 bytes)
//     const dummySide = Buffer.alloc(16);
//     dummySide.writeBigUInt64BE(BigInt(side), 0);
//     dummySide.writeUInt8(side === 0 ? 42 : 99, 8); // Magic bytes for YES/NO
    
//     console.warn("‚ö†Ô∏è Using fallback encryption");
//     return {
//       encryptedAmount: Buffer.alloc(0),
//       encryptedSide: dummySide,
//     };
//   }
// }

import IDL from "./betinco.json";
export type { Betinco } from "./betinco";
export default IDL;

import { Connection, PublicKey } from "@solana/web3.js";
import { AnchorProvider, Program } from "@coral-xyz/anchor";
import IDL from "@/app/idl/betinco.json";

const PROGRAM_ID = new PublicKey("H5xTV9x61nDR2kLTKXekM4YntaNUpCNEDxZYVmZpre77");
const RPC_URL = "https://api.devnet.solana.com"; // Using public RPC but with better retry logic

export interface MarketData {
  id: string;
  question: string;
  deadline: number;
  isSettled: boolean;
  authority: string;
}

export async function fetchAllMarkets(): Promise<MarketData[]> {
  try {
    const connection = new Connection(RPC_URL, "confirmed");
    
    // Get all accounts owned by the program
    const accounts = await connection.getProgramAccounts(PROGRAM_ID, {
      filters: [
        {
          memcmp: {
            offset: 8, // After discriminator
            bytes: "", // Match all markets
          },
        },
      ],
      dataSlice: { offset: 0, length: 500 }, // Get reasonable chunk size
    });

    const markets: MarketData[] = [];

    for (const account of accounts) {
      try {
        // Parse market data
        const data = account.account.data;
        
        // Skip accounts that are too small
        if (data.length < 100) continue;

        // Simple parsing (adjust offsets based on your struct)
        const authority = new PublicKey(data.slice(8, 40)); // After discriminator + padding
        const marketIdBuffer = data.slice(40, 44);
        const marketId = marketIdBuffer.readUInt32LE(0);

        // Skip reading question for performance - just get metadata
        const isSettledOffset = 290; // Approximate offset
        const isSettled = data[isSettledOffset] === 1;

        // Get deadline at approximate offset
        const deadlineOffset = 270;
        const deadline = Number(data.readBigInt64LE(deadlineOffset));

        markets.push({
          id: marketId.toString(),
          question: `Market ${marketId}`, // Default - you can enhance this
          deadline,
          isSettled,
          authority: authority.toString(),
        });
      } catch (e) {
        console.warn("Failed to parse market account:", e);
        continue;
      }
    }

    return markets.sort((a, b) => Number(b.id) - Number(a.id));
  } catch (error) {
    console.error("Error fetching markets:", error);
    return [];
  }
}

export async function fetchMarketDetails(
  marketId: number
): Promise<MarketData | null> {
  try {
    const connection = new Connection(RPC_URL, "confirmed");
    const marketIdBuf = Buffer.alloc(4);
    marketIdBuf.writeUInt32LE(marketId, 0);

    const [marketPda] = PublicKey.findProgramAddressSync(
      [Buffer.from("market"), marketIdBuf],
      PROGRAM_ID
    );

    const account = await connection.getAccountInfo(marketPda);
    if (!account) return null;

    const data = account.data;
    const authority = new PublicKey(data.slice(8, 40));
    const isSettled = data[290] === 1;
    const deadline = Number(data.readBigInt64LE(270));

    return {
      id: marketId.toString(),
      question: `Market ${marketId}`,
      deadline,
      isSettled,
      authority: authority.toString(),
    };
  } catch (error) {
    console.error("Error fetching market details:", error);
    return null;
  }
}